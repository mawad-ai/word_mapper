<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Mapper</title>
    <style>
        /* ===== CSS VARIABLES ===== */
        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1f2e;
            --bg-card: #1e2433;
            --border-color: #2d3548;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-purple: #bc8cff;
            --accent-green: #3fb950;
            --error-red: #f85149;
            --hover-bg: #2d3548;
            --token-bg: #2d3548;
            --token-border: #444c5c;
            --padding-sm: 8px;
            --padding-md: 16px;
            --padding-lg: 24px;
            --radius: 8px;
            --radius-sm: 4px;
        }

        /* ===== GLOBAL STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: var(--padding-lg);
        }

        h1 {
            text-align: center;
            margin-bottom: var(--padding-lg);
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* ===== GRID LAYOUT ===== */
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .visualization-section {
            margin-bottom: var(--padding-lg);
        }

        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--padding-lg);
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: var(--padding-lg);
        }

        .card h2 {
            margin-bottom: var(--padding-md);
            color: var(--accent-blue);
            font-size: 1.5rem;
        }

        /* ===== FORM ELEMENTS ===== */
        .form-group {
            margin-bottom: var(--padding-md);
        }

        label {
            display: block;
            margin-bottom: var(--padding-sm);
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
        }

        input[type="text"],
        input[type="password"],
        select,
        textarea {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: var(--padding-sm) 12px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
        }

        .language-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: var(--padding-md);
            align-items: end;
        }

        /* ===== BUTTONS ===== */
        .button-group {
            display: flex;
            gap: var(--padding-sm);
            margin-top: var(--padding-md);
        }

        button {
            padding: 10px 20px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
        }

        button:hover {
            background: #4a8fd9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        button.secondary:hover {
            background: var(--hover-bg);
        }

        button.test {
            background: var(--accent-purple);
        }

        button.test:hover {
            background: #a678e6;
        }

        /* ===== LOG AREA ===== */
        .log-container {
            margin-top: var(--padding-md);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: var(--padding-sm);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            margin-bottom: 4px;
        }

        .log-header:hover {
            background: var(--hover-bg);
        }

        .log-toggle {
            color: var(--text-secondary);
            font-size: 0.9rem;
            user-select: none;
        }

        .log-area {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: var(--padding-md);
            max-height: 200px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.85rem;
            display: none;
        }

        .log-area.visible {
            display: block;
        }

        .log-entry {
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .log-entry.error {
            color: var(--error-red);
        }

        .log-entry.success {
            color: var(--accent-green);
        }

        .log-timestamp {
            color: var(--accent-purple);
        }

        /* ===== ALIGNMENT VISUALIZATION ===== */
        .alignment-container {
            position: relative;
            margin-top: var(--padding-lg);
            min-height: 300px;
            overflow: visible;
        }

        .token-lane {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: var(--padding-md);
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            margin-bottom: 80px;
            min-height: 60px;
        }

        .token-lane:last-of-type {
            margin-bottom: var(--padding-md);
        }

        .token {
            padding: 8px 16px;
            background: var(--token-bg);
            border: 2px solid var(--token-border);
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .token:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .token.highlight {
            border-color: currentColor;
            box-shadow: 0 0 12px currentColor;
        }

        .svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* ===== LEGEND ===== */
        .legend {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: var(--padding-md);
            margin-top: var(--padding-md);
        }

        .legend h3 {
            margin-bottom: var(--padding-sm);
            color: var(--accent-purple);
            font-size: 1.1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 24px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-text {
            color: var(--text-secondary);
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 1200px) {
            .controls-section {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: var(--padding-sm);
            }

            h1 {
                font-size: 1.5rem;
            }

            .card {
                padding: var(--padding-md);
            }

            .token-lane {
                gap: 8px;
                padding: var(--padding-sm);
                margin-bottom: 60px;
            }

            .token {
                padding: 6px 12px;
                font-size: 0.85rem;
            }

            .alignment-container {
                min-height: 200px;
                overflow: visible;
            }
        }

        /* ===== SCROLLBAR ===== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--hover-bg);
        }
    </style>
</head>

<body>
    <h1>üîó Word Mapper</h1>

    <div class="container">
        <!-- SOURCE TEXT INPUT (TOP) -->
        <div class="visualization-section">
            <div class="card">
                <div style="display: flex; gap: var(--padding-md); align-items: flex-end;">
                    <!-- Source Text -->
                    <div class="form-group" style="flex: 1; margin-bottom: 0;">
                        <label for="sourceText">Source Text</label>
                        <textarea id="sourceText" placeholder="Enter text to translate..." style="min-height: 80px;"></textarea>
                    </div>

                    <!-- Action Buttons -->
                    <div class="button-group" style="margin-bottom: 0; min-width: 300px;">
                        <button onclick="translateAndAlign()">üöÄ Translate & Align</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- VISUALIZATION SECTION (FULL WIDTH) -->
        <div class="visualization-section" id="visualizationSection">
            <!-- Sentence visualizations will be dynamically added here -->
        </div>

        <!-- CONTROLS SECTION (BOTTOM, TWO COLUMNS) -->
        <div class="controls-section">
            <!-- LEFT: SETTINGS & CONTROLS -->
            <div class="card">
                <h2>Settings</h2>

                <!-- Language Selection -->
                <div class="language-row">
                    <div class="form-group">
                        <label for="sourceLang">Source Language</label>
                        <select id="sourceLang">
                            <option value="Dutch" selected>Dutch</option>
                            <option value="English">English</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Spanish">Spanish</option>
                        </select>
                    </div>

                    <button class="secondary" onclick="swapLanguages()" style="flex: 0; padding: 10px 16px;">‚áÑ</button>

                    <div class="form-group">
                        <label for="targetLang">Target Language</label>
                        <select id="targetLang">
                            <option value="Dutch">Dutch</option>
                            <option value="English" selected>English</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Spanish">Spanish</option>
                        </select>
                    </div>
                </div>

                <!-- API Key (Hidden) -->
                <div class="form-group" style="display: none;">
                    <label for="apiKey">OpenAI API Key</label>
                    <input type="password" id="apiKey" placeholder="sk-proj-...">
                </div>

                <!-- Test Button -->
                <div class="button-group">
                    <button class="test" onclick="runSelfTest()">üß™ Run Self-Test</button>
                </div>
            </div>

            <!-- RIGHT: TRANSLATION RESULT -->
            <div class="card">
                <h2>Translation Result</h2>
                <div class="form-group">
                    <label for="targetText">Translated Text</label>
                    <textarea id="targetText" placeholder="Translation will appear here..." readonly style="min-height: 150px;"></textarea>
                </div>

                <!-- Collapsible Log Area -->
                <div class="log-container">
                    <div class="log-header" onclick="toggleLog()">
                        <label style="margin: 0; cursor: pointer;">Activity Log</label>
                        <span class="log-toggle" id="logToggle">‚ñ∂ Show</span>
                    </div>
                    <div class="log-area" id="logArea"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            apiKey: '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',
            model: 'gpt-4o',
            similarityThreshold: 0.3, // Lowered to align more words
            dutchSentences: [
                'De kat slaapt op de bank.',
                'Ik hou van Nederlandse kaas en stroopwafels.',
                'Het weer is vandaag erg mooi en zonnig.',
                'Mijn broer woont in Amsterdam bij het kanaal.',
                'We gaan morgen naar de markt om groenten te kopen.',
                'De kinderen spelen buiten in de tuin.',
                'Deze oude kerk staat al honderd jaar in het dorp.',
                'Zij leest graag boeken over geschiedenis en kunst.',
                'Het Nederlandse landschap is vlak met veel water.',
                'Wij fietsen elke dag naar ons werk in de stad.'
            ]
        };

        // ===== LOGGING UTILITY =====
        function log(message, type = 'info') {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        // ===== TOGGLE LOG VISIBILITY =====
        function toggleLog() {
            const logArea = document.getElementById('logArea');
            const logToggle = document.getElementById('logToggle');
            
            if (logArea.classList.contains('visible')) {
                logArea.classList.remove('visible');
                logToggle.textContent = '‚ñ∂ Show';
            } else {
                logArea.classList.add('visible');
                logToggle.textContent = '‚ñº Hide';
            }
        }

        // ===== LEVENSHTEIN DISTANCE =====
        function levenshtein(a, b) {
            const matrix = [];

            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        // ===== SIMILARITY CALCULATION =====
        function similarity(a, b) {
            const distance = levenshtein(a.toLowerCase(), b.toLowerCase());
            const maxLen = Math.max(a.length, b.length);
            return maxLen === 0 ? 1 : 1 - (distance / maxLen);
        }

        // ===== LIGHT STEMMING =====
        function stem(word) {
            word = word.toLowerCase();
            // Dutch suffixes
            const dutchSuffixes = ['en', 'ing', 'heid', 'lijk', 'baar', 'de', 'te', 'st', 'er'];
            // English suffixes
            const englishSuffixes = ['ing', 'ed', 'ly', 'er', 'est', 's', 'es'];

            const allSuffixes = [...dutchSuffixes, ...englishSuffixes];

            for (const suffix of allSuffixes) {
                if (word.endsWith(suffix) && word.length > suffix.length + 2) {
                    return word.slice(0, -suffix.length);
                }
            }

            return word;
        }

        // ===== TOKENIZATION =====
        function tokenize(text) {
            return text
                .toLowerCase()
                .replace(/[.,!?;:"'()\[\]{}]/g, '')
                .split(/\s+/)
                .filter(t => t.length > 0);
        }

        // ===== SPLIT TEXT INTO SENTENCES =====
        function splitIntoSentences(text) {
            // Simple split on sentence-ending punctuation followed by whitespace or end of line
            const sentences = text
                .trim()
                .split(/(?<=[.!?])\s+/)
                .filter(s => s.trim().length > 0);
            
            // If no splits happened, return the whole text as one sentence
            return sentences.length > 0 ? sentences : [text.trim()];
        }

        // ===== ALIGNMENT ALGORITHM =====
        function alignTokens(sourceTokens, targetTokens) {
            const alignments = [];
            const usedTargets = new Set();
            const usedSources = new Set();

            // First pass: align words with good similarity
            sourceTokens.forEach((srcToken, srcIdx) => {
                let bestMatch = null;
                let bestScore = -1;

                targetTokens.forEach((tgtToken, tgtIdx) => {
                    if (usedTargets.has(tgtIdx)) return;

                    // Calculate base similarity with stemming
                    const stemmedSrc = stem(srcToken);
                    const stemmedTgt = stem(tgtToken);
                    const baseSimilarity = Math.max(
                        similarity(srcToken, tgtToken),
                        similarity(stemmedSrc, stemmedTgt)
                    );

                    // Position-based bonus: prefer alignments that maintain relative order
                    const srcPosition = srcIdx / Math.max(sourceTokens.length - 1, 1);
                    const tgtPosition = tgtIdx / Math.max(targetTokens.length - 1, 1);
                    const positionDiff = Math.abs(srcPosition - tgtPosition);
                    const positionBonus = (1 - positionDiff) * 0.3; // Up to 30% bonus for similar positions

                    // Length similarity bonus: words of similar length are more likely to match
                    const lengthDiff = Math.abs(srcToken.length - tgtToken.length);
                    const maxLength = Math.max(srcToken.length, tgtToken.length);
                    const lengthBonus = (1 - lengthDiff / maxLength) * 0.2; // Up to 20% bonus

                    // Combined score
                    const finalScore = baseSimilarity + positionBonus + lengthBonus;

                    if (finalScore > bestScore) {
                        bestScore = finalScore;
                        bestMatch = tgtIdx;
                    }
                });

                if (bestScore >= CONFIG.similarityThreshold && bestMatch !== null) {
                    alignments.push({
                        source: srcIdx,
                        target: bestMatch,
                        sourceToken: sourceTokens[srcIdx],
                        targetToken: targetTokens[bestMatch],
                        score: bestScore
                    });
                    usedTargets.add(bestMatch);
                    usedSources.add(srcIdx);
                }
            });

            // Second pass: force align remaining words (even with low similarity)
            sourceTokens.forEach((srcToken, srcIdx) => {
                if (usedSources.has(srcIdx)) return;

                let bestMatch = null;
                let bestScore = -999;

                targetTokens.forEach((tgtToken, tgtIdx) => {
                    if (usedTargets.has(tgtIdx)) return;

                    const stemmedSrc = stem(srcToken);
                    const stemmedTgt = stem(tgtToken);
                    const baseSimilarity = Math.max(
                        similarity(srcToken, tgtToken),
                        similarity(stemmedSrc, stemmedTgt)
                    );

                    // Strong position preference for second pass
                    const srcPosition = srcIdx / Math.max(sourceTokens.length - 1, 1);
                    const tgtPosition = tgtIdx / Math.max(targetTokens.length - 1, 1);
                    const positionDiff = Math.abs(srcPosition - tgtPosition);
                    const positionBonus = (1 - positionDiff) * 0.5; // Stronger position weight

                    const finalScore = baseSimilarity + positionBonus;

                    if (finalScore > bestScore) {
                        bestScore = finalScore;
                        bestMatch = tgtIdx;
                    }
                });

                if (bestMatch !== null) {
                    alignments.push({
                        source: srcIdx,
                        target: bestMatch,
                        sourceToken: sourceTokens[srcIdx],
                        targetToken: targetTokens[bestMatch],
                        score: bestScore
                    });
                    usedTargets.add(bestMatch);
                    usedSources.add(srcIdx);
                }
            });

            // Third pass: align any remaining target words
            targetTokens.forEach((tgtToken, tgtIdx) => {
                if (usedTargets.has(tgtIdx)) return;

                // Find closest unused source by position
                let closestSrc = null;
                let minPosDiff = Infinity;

                for (let srcIdx = 0; srcIdx < sourceTokens.length; srcIdx++) {
                    if (!usedSources.has(srcIdx)) {
                        const srcPosition = srcIdx / Math.max(sourceTokens.length - 1, 1);
                        const tgtPosition = tgtIdx / Math.max(targetTokens.length - 1, 1);
                        const posDiff = Math.abs(srcPosition - tgtPosition);

                        if (posDiff < minPosDiff) {
                            minPosDiff = posDiff;
                            closestSrc = srcIdx;
                        }
                    }
                }

                if (closestSrc !== null) {
                    alignments.push({
                        source: closestSrc,
                        target: tgtIdx,
                        sourceToken: sourceTokens[closestSrc],
                        targetToken: tgtToken,
                        score: 0
                    });
                    usedTargets.add(tgtIdx);
                    usedSources.add(closestSrc);
                }
            });

            return alignments;
        }

        // ===== COLOR GENERATION (GOLDEN ANGLE) =====
        function getColor(index) {
            const goldenAngle = 137.508;
            const hue = (index * goldenAngle) % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }

        // ===== VISUALIZATION =====
        function visualizeAlignment(sourceTokens, targetTokens, alignments, containerId) {
            log(`üé® visualizeAlignment called for ${containerId}`);
            console.log('visualizeAlignment params:', { containerId, sourceTokens, targetTokens, alignments });
            
            const container = document.getElementById(containerId);
            if (!container) {
                log(`‚ùå ERROR: Container ${containerId} not found in visualizeAlignment!`, 'error');
                console.error(`Container ${containerId} not found`);
                return;
            }
            log(`‚úÖ Container ${containerId} found`);
            
            const sourceLane = container.querySelector('.source-lane');
            const targetLane = container.querySelector('.target-lane');
            
            if (!sourceLane || !targetLane) {
                log(`‚ùå ERROR: Lanes not found in ${containerId}`, 'error');
                console.error('Lanes not found:', { sourceLane, targetLane });
                return;
            }
            log(`‚úÖ Lanes found in ${containerId}`);

            // Clear previous content
            sourceLane.innerHTML = '';
            targetLane.innerHTML = '';
            log(`üßπ Lanes cleared`);

            // Remove old SVG if exists
            const oldSvg = container.querySelector('.svg-overlay');
            if (oldSvg) oldSvg.remove();

            // Create token elements
            const sourceElements = [];
            const targetElements = [];

            sourceTokens.forEach((token, idx) => {
                const el = document.createElement('div');
                el.className = 'token';
                el.textContent = token;
                el.dataset.index = idx;
                sourceLane.appendChild(el);
                sourceElements.push(el);
            });

            targetTokens.forEach((token, idx) => {
                const el = document.createElement('div');
                el.className = 'token';
                el.textContent = token;
                el.dataset.index = idx;
                targetLane.appendChild(el);
                targetElements.push(el);
            });
            
            log(`üî§ Created ${sourceElements.length} source tokens and ${targetElements.length} target tokens`);
            console.log('Source elements:', sourceElements);
            console.log('Target elements:', targetElements);

            // Create SVG overlay
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('svg-overlay');
            container.insertBefore(svg, sourceLane);

            // Draw curves after layout settles (longer timeout for mobile)
            setTimeout(() => {
                const containerRect = container.getBoundingClientRect();
                
                // Set explicit SVG dimensions
                svg.setAttribute('width', containerRect.width);
                svg.setAttribute('height', containerRect.height);

                // Group alignments by groupId for phrase bundling
                const groupedAlignments = {};
                alignments.forEach(alignment => {
                    const groupId = alignment.groupId ?? alignment.source;
                    if (!groupedAlignments[groupId]) {
                        groupedAlignments[groupId] = [];
                    }
                    groupedAlignments[groupId].push(alignment);
                });

                // Draw each group
                Object.entries(groupedAlignments).forEach(([groupId, group], colorIdx) => {
                    const color = getColor(colorIdx);
                    const isPhrase = group[0].isPhrase;
                    
                    // Get unique source and target elements for this group
                    const srcIndices = [...new Set(group.map(a => a.source))];
                    const tgtIndices = [...new Set(group.map(a => a.target))];
                    
                    const srcElements = srcIndices.map(i => sourceElements[i]).filter(el => el);
                    const tgtElements = tgtIndices.map(i => targetElements[i]).filter(el => el);
                    
                    if (srcElements.length === 0 || tgtElements.length === 0) return;
                    
                    // Set border colors for all elements in group
                    srcElements.forEach(el => el.style.borderColor = color);
                    tgtElements.forEach(el => el.style.borderColor = color);
                    
                    if (isPhrase && (srcElements.length > 1 || tgtElements.length > 1)) {
                        // PHRASE ALIGNMENT: Draw bundled curves with midpoint
                        
                        // Calculate center points for source and target phrases
                        const srcRects = srcElements.map(el => el.getBoundingClientRect());
                        const tgtRects = tgtElements.map(el => el.getBoundingClientRect());
                        
                        const srcCenterX = srcRects.reduce((sum, r) => sum + r.left + r.width / 2, 0) / srcRects.length - containerRect.left;
                        const srcCenterY = Math.max(...srcRects.map(r => r.bottom)) - containerRect.top;
                        
                        const tgtCenterX = tgtRects.reduce((sum, r) => sum + r.left + r.width / 2, 0) / tgtRects.length - containerRect.left;
                        const tgtCenterY = Math.min(...tgtRects.map(r => r.top)) - containerRect.top;
                        
                        // Midpoint between source and target
                        const midX = (srcCenterX + tgtCenterX) / 2;
                        const midY = (srcCenterY + tgtCenterY) / 2;
                        
                        const paths = [];
                        
                        // Draw curves from each source word to midpoint
                        srcElements.forEach(srcEl => {
                            const srcRect = srcEl.getBoundingClientRect();
                            const x1 = srcRect.left + srcRect.width / 2 - containerRect.left;
                            const y1 = srcRect.bottom - containerRect.top;
                            
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const controlOffset = Math.abs(midY - y1) * 0.6;
                            path.setAttribute('d', `M ${x1} ${y1} Q ${x1} ${y1 + controlOffset}, ${midX} ${midY}`);
                            path.setAttribute('stroke', color);
                            path.setAttribute('stroke-width', '2.5');
                            path.setAttribute('fill', 'none');
                            path.setAttribute('opacity', '0.7');
                            svg.appendChild(path);
                            paths.push(path);
                        });
                        
                        // Draw curves from midpoint to each target word
                        tgtElements.forEach(tgtEl => {
                            const tgtRect = tgtEl.getBoundingClientRect();
                            const x2 = tgtRect.left + tgtRect.width / 2 - containerRect.left;
                            const y2 = tgtRect.top - containerRect.top;
                            
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const controlOffset = Math.abs(y2 - midY) * 0.6;
                            path.setAttribute('d', `M ${midX} ${midY} Q ${x2} ${y2 - controlOffset}, ${x2} ${y2}`);
                            path.setAttribute('stroke', color);
                            path.setAttribute('stroke-width', '2.5');
                            path.setAttribute('fill', 'none');
                            path.setAttribute('opacity', '0.7');
                            svg.appendChild(path);
                            paths.push(path);
                        });
                        
                        // Draw midpoint node
                        const midNode = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        midNode.setAttribute('cx', midX);
                        midNode.setAttribute('cy', midY);
                        midNode.setAttribute('r', '5');
                        midNode.setAttribute('fill', color);
                        midNode.setAttribute('opacity', '0.9');
                        svg.appendChild(midNode);
                        paths.push(midNode);
                        
                        // Hover effects for phrase group
                        const highlightGroup = () => {
                            srcElements.forEach(el => el.classList.add('highlight'));
                            tgtElements.forEach(el => el.classList.add('highlight'));
                            paths.forEach(p => {
                                p.setAttribute('stroke-width', '4');
                                p.setAttribute('opacity', '1');
                            });
                            midNode.setAttribute('r', '7');
                        };
                        
                        const unhighlightGroup = () => {
                            srcElements.forEach(el => el.classList.remove('highlight'));
                            tgtElements.forEach(el => el.classList.remove('highlight'));
                            paths.forEach(p => {
                                p.setAttribute('stroke-width', '2.5');
                                p.setAttribute('opacity', '0.7');
                            });
                            midNode.setAttribute('r', '5');
                        };
                        
                        srcElements.forEach(el => {
                            el.addEventListener('mouseenter', highlightGroup);
                            el.addEventListener('mouseleave', unhighlightGroup);
                        });
                        tgtElements.forEach(el => {
                            el.addEventListener('mouseenter', highlightGroup);
                            el.addEventListener('mouseleave', unhighlightGroup);
                        });
                        
                    } else {
                        // SINGLE WORD ALIGNMENT: Draw simple curve
                        const srcEl = srcElements[0];
                        const tgtEl = tgtElements[0];
                        
                        const srcRect = srcEl.getBoundingClientRect();
                        const tgtRect = tgtEl.getBoundingClientRect();
                        
                        const x1 = srcRect.left + srcRect.width / 2 - containerRect.left;
                        const y1 = srcRect.bottom - containerRect.top;
                        const x2 = tgtRect.left + tgtRect.width / 2 - containerRect.left;
                        const y2 = tgtRect.top - containerRect.top;
                        
                        const distance = Math.abs(y2 - y1);
                        const controlOffset = distance * 0.5;
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${x1} ${y1} C ${x1} ${y1 + controlOffset}, ${x2} ${y2 - controlOffset}, ${x2} ${y2}`);
                        path.setAttribute('stroke', color);
                        path.setAttribute('stroke-width', '2.5');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.8');
                        svg.appendChild(path);
                        
                        // Hover effects
                        const highlightPair = () => {
                            srcEl.classList.add('highlight');
                            tgtEl.classList.add('highlight');
                            path.setAttribute('stroke-width', '4');
                            path.setAttribute('opacity', '1');
                        };
                        
                        const unhighlightPair = () => {
                            srcEl.classList.remove('highlight');
                            tgtEl.classList.remove('highlight');
                            path.setAttribute('stroke-width', '2.5');
                            path.setAttribute('opacity', '0.8');
                        };
                        
                        srcEl.addEventListener('mouseenter', highlightPair);
                        srcEl.addEventListener('mouseleave', unhighlightPair);
                        tgtEl.addEventListener('mouseenter', highlightPair);
                        tgtEl.addEventListener('mouseleave', unhighlightPair);
                    }
                });

                log(`‚úì Drew ${alignments.length} alignment curves`, 'success');

                if (alignments.length === 0) {
                    log('‚ö† Warning: No alignments found above threshold', 'error');
                }
            }, 200);
        }

        // ===== OPENAI TRANSLATION =====
        async function translateText(sourceText, sourceLang, targetLang, apiKey) {
            log(`üì§ Sending request to OpenAI (${CONFIG.model})...`);

            const systemPrompt = `You are an expert translator. You must respond with valid JSON only.

Translate from ${sourceLang} to ${targetLang} naturally and idiomatically, then provide word alignments.

You MUST return a JSON object with this structure:
{
  "translation": "the complete translated sentence in natural ${targetLang} word order",
  "alignments": [
    {"source": "word or phrase from source", "target": "corresponding word or phrase in translation"},
    {"source": "next word", "target": "its translation"}
  ]
}

Translation rules:
- Translate naturally using proper ${targetLang} grammar and word order
- Do NOT force source language word order onto the translation
- Use idiomatic expressions when appropriate

Alignment rules:
- Map EVERY word from source to target
- ONLY group multi-word phrases when they form a single semantic unit that cannot be separated
  * Examples of when TO group: "New York" (proper noun), "ice cream" (compound noun), "give up" (phrasal verb)
  * Examples of when NOT to group: articles + nouns ("the cat"), prepositions + nouns ("in Paris"), adjectives + nouns ("red car")
- Prefer word-by-word alignments when possible
- Each source word/phrase appears in exactly one alignment
- Each target word/phrase appears in exactly one alignment
- List alignments in source text order (not translation order)

Example for "Zij praat vandaag een uur met haar buurman":
{
  "translation": "She talks to her neighbor for an hour today",
  "alignments": [
    {"source": "Zij", "target": "She"},
    {"source": "praat", "target": "talks"},
    {"source": "vandaag", "target": "today"},
    {"source": "een", "target": "an"},
    {"source": "uur", "target": "hour"},
    {"source": "met", "target": "to"},
    {"source": "haar", "target": "her"},
    {"source": "buurman", "target": "neighbor"}
  ]
}`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: CONFIG.model,
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: sourceText }
                        ],
                        temperature: 0.3,
                        response_format: { type: 'json_object' }
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error?.message || `HTTP ${response.status}`);
                }

                const content = data.choices[0].message.content.trim();
                log(`ÔøΩ Raw LLM response: ${content.substring(0, 150)}...`);
                
                // Parse JSON response from LLM
                try {
                    // Remove markdown code blocks if present
                    let cleanContent = content;
                    if (content.includes('```')) {
                        cleanContent = content.replace(/```json\n?/gi, '').replace(/```\n?/g, '').trim();
                    }
                    
                    const result = JSON.parse(cleanContent);
                    
                    if (result.translation && result.alignments) {
                        log(`‚úÖ Successfully parsed JSON with ${result.alignments.length} alignments`, 'success');
                        return result;
                    } else {
                        log(`‚ùå JSON missing required fields. Has translation: ${!!result.translation}, Has alignments: ${!!result.alignments}`, 'error');
                        throw new Error('Invalid JSON structure - missing translation or alignments');
                    }
                } catch (parseError) {
                    log(`‚ùå JSON parse failed: ${parseError.message}`, 'error');
                    log(`üëÅÔ∏è Full response: ${content}`, 'error');
                    throw new Error('LLM did not return valid JSON. Check the log for details.');
                }
            } catch (error) {
                log(`‚ùå Translation error: ${error.message}`, 'error');
                throw error;
            }
        }

        // ===== CONVERT LLM ALIGNMENTS TO VISUALIZATION FORMAT =====
        function convertLLMAlignments(llmAlignments, sourceText, targetText) {
            // Tokenize original texts
            const sourceTokens = tokenize(sourceText);
            const targetTokens = tokenize(targetText);
            
            const visualAlignments = [];
            let alignmentCount = 0;
            
            // Track which token indices have been used
            const usedSourceIndices = new Set();
            const usedTargetIndices = new Set();
            
            llmAlignments.forEach((alignment, groupIdx) => {
                const sourcePhrase = tokenize(alignment.source);
                const targetPhrase = tokenize(alignment.target);
                
                log(`  Mapping: "${alignment.source}" ‚Üí "${alignment.target}"`);
                
                // Find next available occurrence of these phrases
                const srcStartIdx = findNextPhraseIndex(sourceTokens, sourcePhrase, usedSourceIndices);
                const tgtStartIdx = findNextPhraseIndex(targetTokens, targetPhrase, usedTargetIndices);
                
                if (srcStartIdx !== -1 && tgtStartIdx !== -1) {
                    // Mark these indices as used
                    for (let i = 0; i < sourcePhrase.length; i++) {
                        usedSourceIndices.add(srcStartIdx + i);
                    }
                    for (let j = 0; j < targetPhrase.length; j++) {
                        usedTargetIndices.add(tgtStartIdx + j);
                    }
                    
                    // Store phrase-level alignment with grouping info
                    const isMultiWord = sourcePhrase.length > 1 || targetPhrase.length > 1;
                    
                    // Create alignment for each word in the phrase
                    for (let i = 0; i < sourcePhrase.length; i++) {
                        for (let j = 0; j < targetPhrase.length; j++) {
                            visualAlignments.push({
                                source: srcStartIdx + i,
                                target: tgtStartIdx + j,
                                sourceToken: sourceTokens[srcStartIdx + i],
                                targetToken: targetTokens[tgtStartIdx + j],
                                score: 1.0,
                                groupId: groupIdx,
                                isPhrase: isMultiWord,
                                phraseSourceIndices: Array.from({length: sourcePhrase.length}, (_, k) => srcStartIdx + k),
                                phraseTargetIndices: Array.from({length: targetPhrase.length}, (_, k) => tgtStartIdx + k)
                            });
                            alignmentCount++;
                        }
                    }
                } else {
                    log(`  ‚ö†Ô∏è Could not find phrase in tokens: src=${srcStartIdx}, tgt=${tgtStartIdx}`, 'error');
                }
            });
            
            log(`‚úì Created ${alignmentCount} visual connections from ${llmAlignments.length} LLM mappings`, 'success');
            return { sourceTokens, targetTokens, alignments: visualAlignments };
        }
        
        // ===== FIND NEXT AVAILABLE PHRASE INDEX IN TOKEN ARRAY =====
        function findNextPhraseIndex(tokens, phrase, usedIndices) {
            for (let i = 0; i <= tokens.length - phrase.length; i++) {
                // Skip if this position is already used
                let positionUsed = false;
                for (let k = 0; k < phrase.length; k++) {
                    if (usedIndices.has(i + k)) {
                        positionUsed = true;
                        break;
                    }
                }
                if (positionUsed) continue;
                
                // Check if phrase matches at this position
                let match = true;
                for (let j = 0; j < phrase.length; j++) {
                    if (tokens[i + j] !== phrase[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) return i;
            }
            return -1;
        }

        // ===== UPDATE URL WITH PARAMETERS =====
        function updateURL(sourceText, sourceLang, targetLang) {
            const params = new URLSearchParams();
            params.set('text', sourceText);
            params.set('from', sourceLang);
            params.set('to', targetLang);
            
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
            log('üîó URL updated with translation parameters');
        }

        // ===== LOAD FROM URL PARAMETERS =====
        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            const text = params.get('text');
            const from = params.get('from');
            const to = params.get('to');
            
            if (text) {
                document.getElementById('sourceText').value = text;
                log(`üì• Loaded text from URL: "${text.substring(0, 50)}..."`);
                
                if (from) {
                    document.getElementById('sourceLang').value = from;
                    log(`üåç Source language: ${from}`);
                }
                
                if (to) {
                    document.getElementById('targetLang').value = to;
                    log(`üåç Target language: ${to}`);
                }
                
                return true; // Indicates URL parameters were found
            }
            
            return false;
        }

        // ===== MAIN TRANSLATION & ALIGNMENT FUNCTION =====
        async function translateAndAlign() {
            const sourceText = document.getElementById('sourceText').value.trim();
            const targetTextArea = document.getElementById('targetText');
            const apiKey = document.getElementById('apiKey').value.trim();
            const sourceLang = document.getElementById('sourceLang').value;
            const targetLang = document.getElementById('targetLang').value;

            if (!sourceText) {
                log('‚ùå Please enter source text', 'error');
                return;
            }

            if (!apiKey) {
                log('‚ùå Please enter API key', 'error');
                return;
            }

            // Update URL with current parameters
            updateURL(sourceText, sourceLang, targetLang);

            // Split text into sentences
            const sentences = splitIntoSentences(sourceText);
            log(`üìù Split text into ${sentences.length} sentence(s)`);
            log(`üöÄ Starting translation: ${sourceLang} ‚Üí ${targetLang}`);

            // Clear previous visualizations
            const visualizationSection = document.getElementById('visualizationSection');
            
            if (!visualizationSection) {
                log('‚ùå CRITICAL: visualizationSection element not found!', 'error');
                console.error('visualizationSection element not found in DOM');
                return;
            }
            
            log(`üîç Debug: visualizationSection found, clearing content...`);
            visualizationSection.innerHTML = '';
            log(`üîç Debug: visualizationSection cleared`);
            
            // Clear translation result
            targetTextArea.value = '';
            
            const allTranslations = [];

            try {
                // Process each sentence
                for (let i = 0; i < sentences.length; i++) {
                    const sentence = sentences[i];
                    log(`\nüìç Processing sentence ${i + 1}/${sentences.length}: "${sentence}"`);
                    
                    // Translate and get alignments from LLM
                    const result = await translateText(sentence, sourceLang, targetLang, apiKey);
                    
                    if (!result.translation || !result.alignments) {
                        throw new Error(`LLM did not return proper format for sentence ${i + 1}.`);
                    }
                    
                    const translation = result.translation;
                    allTranslations.push(translation);

                    // Use LLM-provided alignments ONLY
                    log(`üß† Using LLM-provided alignments (${result.alignments.length} mappings)`, 'success');
                    const converted = convertLLMAlignments(result.alignments, sentence, translation);
                    const sourceTokens = converted.sourceTokens;
                    const targetTokens = converted.targetTokens;
                    const alignments = converted.alignments;
                    
                    log(`üî§ Tokenized: ${sourceTokens.length} source, ${targetTokens.length} target tokens`);
                    log(`üîó Created ${alignments.length} visual alignments`);

                    // Create visualization box for this sentence
                    const containerId = `alignment-container-${i}`;
                    log(`üî® Creating card element for sentence ${i + 1}...`);
                    
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.style.marginBottom = 'var(--padding-lg)';
                    card.style.display = 'block';
                    card.style.width = '100%';
                    card.style.minHeight = '300px';
                    card.style.backgroundColor = 'var(--bg-card)';
                    card.innerHTML = `
                        <h2>Sentence ${i + 1}</h2>
                        <div class="alignment-container" id="${containerId}">
                            <div class="token-lane source-lane"></div>
                            <div class="token-lane target-lane"></div>
                        </div>
                    `;
                    
                    log(`üî® Appending card to visualizationSection...`);
                    visualizationSection.appendChild(card);
                    
                    // Verify card was added
                    const cardCount = visualizationSection.children.length;
                    log(`üì¶ Card added! Total cards: ${cardCount}`);
                    console.log(`Sentence ${i + 1} card:`, card);
                    console.log(`VisualizationSection children:`, visualizationSection.children);

                    // Wait a moment for DOM to update
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Verify container exists
                    const container = document.getElementById(containerId);
                    if (!container) {
                        log(`‚ùå ERROR: Container ${containerId} not found after creation!`, 'error');
                        console.error(`Container ${containerId} not found`);
                        continue;
                    }
                    log(`‚úÖ Container ${containerId} found in DOM`);

                    // Visualize this sentence
                    visualizeAlignment(sourceTokens, targetTokens, alignments, containerId);
                }
                
                // Update translation result with all translations
                targetTextArea.value = allTranslations.join(' ');
                log(`\n‚úÖ All ${sentences.length} sentence(s) processed successfully!`, 'success');

            } catch (error) {
                targetTextArea.value = `Error: ${error.message}`;
                log(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // ===== SWAP LANGUAGES =====
        function swapLanguages() {
            const sourceLang = document.getElementById('sourceLang');
            const targetLang = document.getElementById('targetLang');
            const sourceText = document.getElementById('sourceText');
            const targetText = document.getElementById('targetText');

            // Swap language selections
            const tempLang = sourceLang.value;
            sourceLang.value = targetLang.value;
            targetLang.value = tempLang;

            // Swap text content
            const tempText = sourceText.value;
            sourceText.value = targetText.value;
            targetText.value = tempText;

            log('üîÑ Swapped languages and text');
        }

        // ===== SELF-TEST ROUTINE =====
        async function runSelfTest() {
            log('üß™ Starting self-test with demo sentences...', 'success');

            const testSentences = [
                'De kat slaapt op de bank.',
                'Het weer is vandaag erg mooi en zonnig.',
                'Wij fietsen elke dag naar ons werk in de stad.'
            ];

            for (let i = 0; i < testSentences.length; i++) {
                log(`\n--- Test ${i + 1}/${testSentences.length} ---`);
                document.getElementById('sourceText').value = testSentences[i];
                await translateAndAlign();
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            log('‚úÖ Self-test completed!', 'success');
        }

        // ===== RANDOM SENTENCE SELECTOR =====
        function getRandomDutchSentence() {
            return CONFIG.dutchSentences[Math.floor(Math.random() * CONFIG.dutchSentences.length)];
        }

        // ===== API CONNECTION TEST =====
        async function testAPIConnection() {
            log('üîç Testing API connection...');
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${CONFIG.apiKey}`
                    }
                });
                
                if (response.ok) {
                    log('‚úÖ API key is valid and connected!', 'success');
                    return true;
                } else {
                    const data = await response.json();
                    log(`‚ùå API connection failed: ${data.error?.message || response.statusText}`, 'error');
                    return false;
                }
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`, 'error');
                return false;
            }
        }

        // ===== AUTO-INITIALIZATION ON PAGE LOAD =====
        window.addEventListener('DOMContentLoaded', async () => {
            // Auto-fill API key
            document.getElementById('apiKey').value = CONFIG.apiKey;
            log('üîë API key auto-filled');

            // Check for URL parameters first
            const hasURLParams = loadFromURL();

            // Test API connection first
            const isConnected = await testAPIConnection();
            
            if (!isConnected) {
                log('‚ö†Ô∏è Skipping auto-translation due to API connection failure', 'error');
                return;
            }

            if (hasURLParams) {
                // Auto-translate from URL parameters
                log('‚ö° Auto-executing translation from URL...');
                translateAndAlign();
            } else {
                // Auto-fill random Dutch sentence
                const randomSentence = getRandomDutchSentence();
                document.getElementById('sourceText').value = randomSentence;
                log(`üìù Random Dutch sentence loaded: "${randomSentence}"`);

                // Auto-run translation immediately
                log('‚ö° Auto-executing translation...');
                translateAndAlign();
            }
        });
    </script>
</body>

</html>
